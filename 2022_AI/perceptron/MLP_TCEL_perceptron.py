# MLP
# 4 class : T/C/E/L
# 3 patterns / 1 class
# 2 Layer

import numpy as np
import math as m


def sigmoid(x):
    return (1.0 / (1 + m.exp(-x)))


lrate = 0.1
INDIM = 26
H1DIM = 10
OUTDIM = 4

PTTN_NUM = 12

x = np.array([[1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0],  # T-1
              [1.0, 1.0, 1.0, 1.0, 1.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 1.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0],  # T-2
              [1.0, 0.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0,
               0.0, 0.0, 1.0, 0.0, 0.0],  # T-3
              [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0],  # C-1
              [1.0, 1.0, 1.0, 1.0, 1.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0],  # C-2
              [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 0.0],  # C-3
              [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0],  # E-1
              [1.0, 0.5, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0],  # E-2
              [1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               0.5, 1.0, 1.0, 1.0, 1.0],  # E-3
              [1.0, 1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 1.0, 1.0, 1.0, 1.0],  # L-1
              [1.0, 1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 1.0,
               1.0, 1.0, 1.0, 1.0, 0.0],  # L-2
              [1.0, 1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               1.0, 0.0, 0.0, 0.0, 0.0,
               0.3, 1.0, 1.0, 1.0, 1.0]])  # L-3

t = np.array([[1.0, 0.0, 0.0, 0.0],
              [1.0, 0.0, 0.0, 0.0],
              [1.0, 0.0, 0.0, 0.0],
              [0.0, 1.0, 0.0, 0.0],
              [0.0, 1.0, 0.0, 0.0],
              [0.0, 1.0, 0.0, 0.0],
              [0.0, 0.0, 1.0, 0.0],
              [0.0, 0.0, 1.0, 0.0],
              [0.0, 0.0, 1.0, 0.0],
              [0.0, 0.0, 0.0, 1.0],
              [0.0, 0.0, 0.0, 1.0],
              [0.0, 0.0, 0.0, 1.0]])

w1 = np.zeros([H1DIM, INDIM])
for i in range(H1DIM):
    for j in range(INDIM):
        w1[i][j] = np.random.rand() / 10.0

w2 = np.zeros([OUTDIM, H1DIM])
for i in range(OUTDIM):
    for j in range(H1DIM):
        w2[i][j] = np.random.rand() / 10.0

print(w1)
print(w2)

y1 = np.zeros(H1DIM)
y2 = np.zeros(OUTDIM)

d1 = np.zeros(H1DIM)
d2 = np.zeros(OUTDIM)

for epoch in range(20000):
    if (epoch % 1000) == 0:
        print("epoch", epoch)
    for p in range(PTTN_NUM):
        ###########################################
        # feed forwarding
        ###########################################
        # LAYER-1 (Hidden Layer)
        for i in range(H1DIM):
            out = 0.0
            for j in range(INDIM):
                out += w1[i][j] * x[p][j]
            y1[i] = sigmoid(out)
        # LAYER-2 (Output Layer)
        # y1[0] = 1.0  ### bias

        for i in range(OUTDIM):
            out = 0.0
            for j in range(H1DIM):
                out += w2[i][j] * y1[j]
            y2[i] = sigmoid(out)

        ###########################################
        # Back Propagation
        ###########################################
        # delta(error)  for Layer-2 (Output Layer)
        for i in range(OUTDIM):
            d2[i] = (t[p][i] - y2[i]) * (y2[i] * (1 - y2[i]))
        # delta(error)  for Layer-1 (Hidden Layer)
        for i in range(H1DIM):
            for j in range(OUTDIM):
                d1[i] = d2[j] * w2[j][i] * (y1[i] * (1 - y1[i]))

        ###########################################
        # Weight Adjustment
        ###########################################
        # for Layer-2 (Output Layer)
        for i in range(OUTDIM):
            for j in range(H1DIM):
                w2[i][j] += lrate * d2[i] * y1[j]

        # for Layer-1 (Hidden Layer)
        for i in range(H1DIM):
            for j in range(INDIM):
                w1[i][j] += lrate * d1[i] * x[p][j]

        if (epoch % 1000) == 0:
            print("pattern number[%d] : " % p)
            print("target : ", "%7.2f" % t[p][0], "%7.2f" % t[p][1], "%7.2f" % t[p][2], "%7.2f" % t[p][3])
            print("output : ", "%7.2f" % y2[0], "%7.2f" % y2[1], "%7.2f" % y2[2], "%7.2f" % y2[3])

